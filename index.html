<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>著信科技|探索共同的未知</title>
    <link href="css/index.css" rel="stylesheet"/>
    <link rel="bookmark" type="image/x-icon" href="favicon.ico"/>
    <link rel="shortcut icon" href="favicon.ico">
</head>
<body>
<img class="linelogo" src="images/zhuxinlogo2.png"/>
<div id="loadline"></div>
<div id="loadline2"></div>
<div id="loadline3">
    <div id="canvasdiv"></div>
    <div class="logodiv">
        <img class="logo" src="images/zhuxinlogo.png"/>
        <div id="logoline"></div>
    </div>

    <div class="about_arrow">
        <div class="about_title">关于我们</div>

            <svg viewBox="0 0 200 10"><polyline points="0,8 200,8 200,7 50,7 50,1 0,8" style="fill:rgba(255,255,255,50);stroke:white;"></polyline></svg>

    </div>
    <div id="menuLine" class="menuLine">
        <a class="menuLine_open" href="#">
            <span></span>
            <span></span>
            <span></span>
        </a>
    </div>
    <div class="legal">
        ©北京著信科技有限公司.
    </div>
</div>

</body>
<script src="https://cdn.bootcss.com/three.js/r83/three.min.js"></script>
<script>
    var loadline = document.getElementById("loadline");
    var loadline2 = document.getElementById("loadline2");
    var loadline3 = document.getElementById("loadline3");
    loadline.addEventListener("webkitAnimationEnd", function() {
        loadline.style.display="none";
        loadline2.style.display="inline";
        threeStart();
    });

    loadline2.addEventListener("webkitAnimationEnd", function() {
        loadline2.style.display="none";
        loadline3.style.display="inline";
    });


    loadline3.addEventListener("webkitAnimationStart", function() {

    });

     document.getElementById("menuLine").addEventListener('click', function () {
         var json=camera.toJSON();
         var str=JSON.stringify(json);
         alert(str);
     });

    // $("#menuLine").click(function () {
    //     var json=camera.toJSON();
    //     var str=JSON.stringify(json);
    //     alert(str);
    // });

    document.addEventListener('DOMContentLoaded', function () {
        // threeStart();
    });
    var controls;
    function threeStart() {
        initThree();
        initCamera();
        initScene();
        initLight();
        createEarth();
        // createLnglat();
        // createLine();
        createStar();
        // initClouds();

        animate();
    }

    // 渲染器
    var width, height;
    var renderer;
    var maxfar = 1000000;

    function initThree() {
        width = window.innerWidth;
        height = window.innerHeight;
        renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true,
            canvas: renderer
        });
        renderer.setSize(width, height);
        document.getElementById('canvasdiv').appendChild(renderer.domElement);
        window.addEventListener('resize', onWindowResize, false);
    }

    function onWindowResize() {
        width = window.innerWidth;
        height = window.innerHeight;
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
    }

    // 相机
    var camera;

    function initCamera() {
        camera = new THREE.PerspectiveCamera(45, width / height, 1, maxfar);
        camera.position.x = -105;
        camera.position.y = 260;
        camera.position.z = 505;
        camera.rotation.x= -0.47;
        camera.rotation.y =-0.72;
        camera.rotation.z = -0.33;
        // controls = new THREE.OrbitControls(camera,renderer.domElement);
        // controls.update();
        camera.updateProjectionMatrix();

        // controls.update();
    }

    // 场景
    var scene;

    function initScene() {
        scene = new THREE.Scene();
    }

    // 光源
    var light;

    function initLight() {

        // A light source positioned directly above the scene, with color fading from the sky color to the ground color.
        // 位于场景正上方的光源，颜色从天空颜色渐变为地面颜色。
        //  var light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);
        // scene.add(light);

        // 环境光
        light = new THREE.AmbientLight(0xFFFFFF);
        light.position.set(100, 100, 200);
        scene.add(light);

        // 平行光
        // 位置不同，方向光作用于物体的面也不同，看到的物体各个面的颜色也不一样
        // light = new THREE.DirectionalLight(0xffffbb, 1);
        // light.position.set(-1, 1, 1);
        // scene.add(light);
    }

    // 地球
    var earthMesh;
    var earthgroup = new THREE.Group();

    function createEarth() {
        scene.add(earthgroup);
        var earthGeo = new THREE.SphereGeometry(240, 100, 100);
        var url = './images/MapDark.jpg';
        var earthMater = new THREE.MeshPhongMaterial({
            map: new THREE.TextureLoader().load(url),
            transparent: false,
            opacity: 0.5
        });
        earthMesh = new THREE.Mesh(earthGeo, earthMater);
        // earthMesh.position.x= -360;
        // earthMesh.position.y = 20;
        // earthMesh.position.z= -260;
        // earthMesh.rotation.x= 0.36;
        // earthMesh.rotation.y = 2.6;
        earthgroup.add(earthMesh);
    }

    function createLnglat() {
        var earthrad = 245;
        var geometry_lng = new THREE.TorusGeometry(earthrad, 0.5, 5, 100);
        var material = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.2
        });
        var torus;
        //经线
        var step = 18;
        for (var i = 0; i < 180; i += step) {
            torus = new THREE.Mesh(geometry_lng, material);
            torus.rotation.y = (Math.PI / 2) * i / 90;
            earthgroup.add(torus);
        }

        //纬线
        for (var i = -85; i < 85; i += step) {
            var h = Math.sin((Math.PI / 2) * i / 90) * earthrad;
            var l = Math.cos((Math.PI / 2) * i / 90) * earthrad;
            var geometry_lng = new THREE.TorusGeometry(l, 0.5, 5, 100);
            torus = new THREE.Mesh(geometry_lng, material);
            torus.position.y = h;
            torus.rotation.x = Math.PI / 2;
            earthgroup.add(torus);
        }

    }

    var particles_star;
    var numParticles_star = 1000;
    var mindistance = 500;

    function createStar() {
        //wave
        var positions = new Float32Array(numParticles_star * 3);
        var scales = new Float32Array(numParticles_star);
        var colors = new Float32Array(numParticles_star * 3);
        var i = 0, j = 0;
        for (var ix = 0; ix < numParticles_star; ix++) {
            var x = THREE.Math.randFloat(-50000, 50000);
            var y = THREE.Math.randFloat(-50000, 50000);
            var z = THREE.Math.randFloat(-50000, 50000);

            // if(x<mindistance){
            //     x+=mindistance;
            // }
            // if(y<mindistance){
            //     y+=mindistance;
            // }
            // if(z<mindistance){
            //     z+=mindistance;
            // }
            positions[i] = x;
            positions[i + 1] = y;
            positions[i + 2] = z;

            colors[i] = THREE.Math.randFloat(0.7, 1.0);
            colors[i + 1] = THREE.Math.randFloat(0.7, 1.0);
            colors[i + 2] = THREE.Math.randFloat(0.7, 1.0);
            scales[j] = THREE.Math.randFloatSpread(50);
            i += 3;
            j++;
        }
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.addAttribute('scale', new THREE.BufferAttribute(scales, 1));
        geometry.addAttribute('color', new THREE.BufferAttribute(colors, 3));
        var material = new THREE.PointsMaterial({
            size: 600,
            vertexColors: THREE.VertexColors,
            transparent: true,
            opacity: 1.0
        });
        var pointsMaterial = new THREE.PointsMaterial({
            vertexColors: THREE.VertexColors,
            size: 500,
            transparent: true,//使材质透明
            blending: THREE.AdditiveBlending,
            // depthTest:false,//深度测试关闭，不消去场景的不可见面
            map: createLightMateria()//刚刚创建的粒子贴图就在这里用上
        });
        particles_star = new THREE.Points(geometry, pointsMaterial);
        scene.add(particles_star);
    }


    var r = 800;
    var rHalf = r / 2;
    var particles_line;
    var particleCount = 500;
    var numParticles_line = 1000;
    var segments = numParticles_line * numParticles_line;
    var positions_line = new Float32Array(segments * 3);
    var colors_line = new Float32Array(segments * 3);
    var particlesData = [];
    var particlePositions;
    var pointCloud;
    var linesMesh;

    function createLine() {
        var group = new THREE.Group();
        scene.add(group);

        particlePositions = new Float32Array(numParticles_line * 3);
        for (var i = 0; i < numParticles_line; i++) {
            var x = Math.random() * r - r / 2;
            var y = Math.random() * r - r / 2;
            var z = Math.random() * r - r / 2;
            particlePositions[i * 3] = x;
            particlePositions[i * 3 + 1] = y;
            particlePositions[i * 3 + 2] = z;
            // add it to the geometry
            particlesData.push({
                velocity: new THREE.Vector3(-1 + Math.random() * 2, -1 + Math.random() * 2, -1 + Math.random() * 2),
                numConnections: 0
            });
        }
        particles_line = new THREE.BufferGeometry();
        particles_line.setDrawRange(0, particleCount);
        particles_line.addAttribute('position', new THREE.BufferAttribute(particlePositions, 3).setDynamic(true));

        var pMaterial = new THREE.PointsMaterial({
            color: 0xFFFFFF,
            size: 3,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.1,
            sizeAttenuation: false
        });

        // create the particle system
        pointCloud = new THREE.Points(particles_line, pMaterial);
        group.add(pointCloud);

        //create line
        var geometry = new THREE.BufferGeometry();
        geometry.addAttribute('position', new THREE.BufferAttribute(positions_line, 3).setDynamic(true));
        geometry.addAttribute('color', new THREE.BufferAttribute(colors_line, 3).setDynamic(true));
        geometry.computeBoundingSphere();
        geometry.setDrawRange(0, 0);
        var material = new THREE.LineBasicMaterial({
            color: 0xAAAAAA,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 0.1
        });
        linesMesh = new THREE.LineSegments(geometry, material);
        group.add(linesMesh);
    }

    function createLightMateria() {
        let canvasDom = document.createElement('canvas');
        canvasDom.width = 32;
        canvasDom.height = 32;
        let ctx = canvasDom.getContext('2d');
        //根据参数确定两个圆的坐标，绘制放射性渐变的方法，一个圆在里面，一个圆在外面
        let gradient = ctx.createRadialGradient(
            canvasDom.width / 2,
            canvasDom.height / 2,
            0,
            canvasDom.width / 2,
            canvasDom.height / 2,
            canvasDom.width / 2);
        //设置偏移值和颜色值

        //蓝色
        /*
          gradient.addColorStop(0,'rgba(255,255,255,1)');
          gradient.addColorStop(0.2,'rgba(0,255,255,1)');
          gradient.addColorStop(0.4,'rgba(0,0,64,1)');
          gradient.addColorStop(1,'rgba(0,0,0,1)');
         */

        //红色
        /*
        gradient.addColorStop(0,'rgba(255,255,255,1)');
        gradient.addColorStop(0.2,'rgba(255,182,193,1)');
        gradient.addColorStop(0.4,'rgba(64,0,0,1)');
        gradient.addColorStop(1,'rgba(0,0,0,1)');
        */

        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.3, 'rgba(200,200,200,0.9)');
        gradient.addColorStop(0.6, 'rgba(100,100,100,0.6)');
        gradient.addColorStop(0.9, 'rgba(50,50,50,0.3)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');

        //设置ctx为渐变色
        ctx.fillStyle = gradient;
        //绘图
        ctx.fillRect(0, 0, canvasDom.width, canvasDom.height);

        //贴图使用
        let texture = new THREE.Texture(canvasDom);
        texture.needsUpdate = true;//使用贴图时进行更新
        return texture;
    }

    // 云
    var cloudsMesh;

    function initClouds() {
        var cloudsGeo = new THREE.SphereGeometry(260, 100, 100);
        var cloudsMater = new THREE.MeshPhongMaterial({
            alphaMap: new THREE.TextureLoader().load('./assets/clouds.jpg'),
            transparent: true,
            opacity: 0.2
        });
        cloudsMesh = new THREE.Mesh(cloudsGeo, cloudsMater);
        // cloudsMesh.position.x= -360;
        // cloudsMesh.position.y = 20;
        // cloudsMesh.position.z= -260;
        // cloudsMesh.rotation.y = 1.5;
        scene.add(cloudsMesh);
    }

    function animate() {
        // 地球自转
        earthgroup.rotation.y += 0.0005;

        // // 漂浮的云层
        // cloudsMesh.rotation.y += 0.0005;

        //star
        // var positions = particles_star.geometry.attributes.position.array;
        // for ( var ix = 0; ix < numParticles_star; ix ++ ) {
        //     var i=ix*3;
        //     var deltal=THREE.Math.randFloat(0,20);
        //     positions[i] +=deltal;
        //     positions[i + 1] +=  deltal;
        //     positions[i + 2] +=  deltal;
        // }
        particles_star.geometry.attributes.position.needsUpdate = true;
        particles_star.rotation.y -= 0.0005;

        // // line
        // animateline();

        renderer.render(scene, camera);
        requestAnimationFrame(animate);
    }

    function animateline() {
        var minDistance = 150;
        var vertexpos = 0;
        var colorpos = 0;
        var numConnected = 0;
        for (var i = 0; i < particleCount; i++)
            particlesData[i].numConnections = 0;
        for (var i = 0; i < particleCount; i++) {
            // get the particle
            var particleData = particlesData[i];
            particlePositions[i * 3] += particleData.velocity.x;
            particlePositions[i * 3 + 1] += particleData.velocity.y;
            particlePositions[i * 3 + 2] += particleData.velocity.z;
            if (particlePositions[i * 3 + 1] < -rHalf || particlePositions[i * 3 + 1] > rHalf)
                particleData.velocity.y = -particleData.velocity.y;
            if (particlePositions[i * 3] < -rHalf || particlePositions[i * 3] > rHalf)
                particleData.velocity.x = -particleData.velocity.x;
            if (particlePositions[i * 3 + 2] < -rHalf || particlePositions[i * 3 + 2] > rHalf)
                particleData.velocity.z = -particleData.velocity.z;
            // Check collision
            for (var j = i + 1; j < particleCount; j++) {
                var particleDataB = particlesData[j];
                var dx = particlePositions[i * 3] - particlePositions[j * 3];
                var dy = particlePositions[i * 3 + 1] - particlePositions[j * 3 + 1];
                var dz = particlePositions[i * 3 + 2] - particlePositions[j * 3 + 2];
                var dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
                if (dist < minDistance) {
                    particleData.numConnections++;
                    particleDataB.numConnections++;
                    var alpha = 1.0 - dist / minDistance;
                    positions_line[vertexpos++] = particlePositions[i * 3];
                    positions_line[vertexpos++] = particlePositions[i * 3 + 1];
                    positions_line[vertexpos++] = particlePositions[i * 3 + 2];
                    positions_line[vertexpos++] = particlePositions[j * 3];
                    positions_line[vertexpos++] = particlePositions[j * 3 + 1];
                    positions_line[vertexpos++] = particlePositions[j * 3 + 2];
                    colors_line[colorpos++] = alpha;
                    colors_line[colorpos++] = alpha;
                    colors_line[colorpos++] = alpha;
                    colors_line[colorpos++] = alpha;
                    colors_line[colorpos++] = alpha;
                    colors_line[colorpos++] = alpha;
                    numConnected++;
                }
            }
        }
        linesMesh.geometry.setDrawRange(0, numConnected * 2);
        linesMesh.geometry.attributes.position.needsUpdate = true;
        linesMesh.geometry.attributes.color.needsUpdate = true;
        pointCloud.geometry.attributes.position.needsUpdate = true;
    }

</script>

</html>